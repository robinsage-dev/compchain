const redis = require('redis');
const Debug = require_robinbase('Debug').prefix('Redis Storage');
const Schema = require_robinbase('base:Schema');

const filter = require('../_utils/filter');
const sort = require('../_utils/sort');

const serverId$ = Symbol('server id');

const RedisLiveStorage = function(options)
{
    const self = this;

    self[serverId$] = Schema.utils.randomId();
    self.options = options;
    self.pubClient = null;
    self.subClient = null;
    self.subscriptions = {};
    self.channels = {};
};

RedisLiveStorage.prototype.init = function(callback)
{
    const self = this;
    let connected = false;
    self.pubClient = redis.createClient(self.options);
    self.subClient = redis.createClient(self.options);
    self.pubClient.on('error', function(err)
    {
        if (!connected)
        {
            callback(err);
        }

        Debug.log('Redis Error', err);
    });

    self.pubClient.on('ready', function()
    {
        if (!connected)
        {
            connected = true;
            Debug.log('Redis Connected', self.options.server + ':' + self.options.port);
            callback(null);
        }
    });

    self.subClient.on('message', (channel, message) =>
    {
        if (!Array.isArray(self.subscriptions[channel]) || self.subscriptions[channel].length == 0)
        {
            return;
        }

        try
        {
            message = JSON.parse(message);
        }
        catch (e)
        {
            Debug.error('Could not parse redis value', e);
        }

        self._process(self.channels[channel], self.subscriptions[channel], message);
    });
};

RedisLiveStorage.prototype.prepareCollection = function(myClass, callback)
{
    const self = this;
    myClass.storage = self;

    const collectionKey = RedisLiveStorage.getCollectionKey(myClass.collection);

    self.subscriptions[collectionKey] = [];
    self.subClient.subscribe(collectionKey);
    self.channels[collectionKey] = myClass;

    return callback(null);
};

RedisLiveStorage.prototype.get = function(myClass, query, options, callback)
{
    callback(new Error('Opration not supported'));
};

RedisLiveStorage.prototype.count = function(myClass, query, callback)
{
    callback(new Error('Opration not supported'));
};

RedisLiveStorage.prototype.update = function(myClass, object, query, setter, callback)
{
    const self = this;
    const collectionKey = RedisLiveStorage.getCollectionKey(myClass.collection);
    const useId = myClass.schema.useId;

    // TODO: the setter should be smarter than this
    const newObj = new myClass(Object.assign({}, object, setter));
    const id = newObj[useId];

    self.pubClient.publish(collectionKey, JSON.stringify({
        action: 'UPDATE',
        id,
        original: object,
        current: newObj,
        time: new Date().toISOString(),
    }));

    if (typeof callback === 'function')
    {
        callback(null, newObj);
    }
};

RedisLiveStorage.prototype.delete = function(myClass, object, query, callback)
{
    const self = this;
    const collectionKey = RedisLiveStorage.getCollectionKey(myClass.collection);
    const useId = myClass.schema.useId;
    const id = object[useId];

    self.pubClient.publish(collectionKey, JSON.stringify({
        action: 'DELETE',
        id,
        original: object,
        current: null,
        time: new Date().toISOString(),
    }));

    if (typeof callback === 'function')
    {
        callback(null, object);
    }
};

RedisLiveStorage.prototype.create = function(myClass, record, callback)
{
    const self = this;
    const collectionKey = RedisLiveStorage.getCollectionKey(myClass.collection);
    const useId = myClass.schema.useId;

    if (!record[useId])
    {
        record[useId] = Schema.utils.randomId();
    }

    const id = record[useId];

    self.pubClient.publish(collectionKey, JSON.stringify({
        action: 'CREATE',
        id,
        original: null,
        current: record,
        time: new Date().toISOString(),
    }));

    if (typeof callback === 'function')
    {
        callback(null, record);
    }
};

RedisLiveStorage.prototype.createSubscription = function(myClass, filter, onData, callback)
{
    const self = this;

    const collectionKey = RedisLiveStorage.getCollectionKey(myClass.collection);

    if(!Array.isArray(self.subscriptions[collectionKey]))
    {
        return callback(new Error('collection is not registered'));
    }

    const subscription = {
        filter,
        onData,
        Model: myClass,
    };

    const cancelHandle = () =>
    {
        this.subscriptions[collectionKey] = this.subscriptions[collectionKey].filter((item) => item != subscription);
    };

    this.subscriptions[collectionKey].push(subscription);

    callback(null, cancelHandle);
};

RedisLiveStorage.prototype._process = function(myClass, subscriptions, data)
{
    let filterData = data.current;
    if (data.action === 'DELETE')
    {
        filterData = data.original;
    }

    filterData = new myClass(filterData);


    subscriptions.forEach((subscription) =>
    {
        const filtered = filter([filterData], subscription.filter || {});

        if (filtered.length == 0)
        {
            return;
        }

        subscription.onData(data);
    });
};

RedisLiveStorage.getCollectionKey = function getCollectionKey(collectionName)
{
    return 'rbcollection:' + collectionName;
};

module.exports = RedisLiveStorage;
