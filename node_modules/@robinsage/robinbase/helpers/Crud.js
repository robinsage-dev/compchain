var Crud = {};
var Schema = require('./Schema');
const Transaction = require_robinbase('base:service:database:Transaction');

Crud.addCrudToClass = function(myClass)
{
    var Debug = require('./Debug').prefix('crud:'+myClass.name);

    var requiredHooks = [
        "beforeCreate",
        "afterCreate",
        "beforeUpdate",
        "afterUpdate",
        "beforeSave",
        "afterSave",
        "beforeDelete",
        "afterDelete",
        "beforeClone",
        "afterClone",
    ];

    requiredHooks.forEach(function(hookName)
    {
        if (typeof myClass.prototype[hookName] === 'function')
        {
            myClass.on(hookName, function(instance, callback)
            {
                instance[hookName](callback);
            });
        }
    });

    if (typeof myClass.crud === 'undefined')
    {
        myClass.crud = {};
    }

    if (typeof myClass.crud.get === 'undefined')
    {
        myClass.crud.get = function(_query, _options, authorization, callback)
        {
            if (arguments.length === 2)
            {
                callback = _options;
                _options = {};
                authorization = null;
            }
            else if (arguments.length === 3)
            {
                callback = authorization;
                authorization = null;
            }

            var query = _query || {};
            var options = _options || {};

            if (authorization)
            {
                if (authorization.isAccessDenied("view"))
                {
                    return callback("You do not have permission to perform this action.", null);
                }
                query = authorization.applyQueryFilters("view", query);
                options.deniedKeys = myClass.view.hidden;
            }

            options.sort = options.sort || [myClass.schema.useId, 'desc'];

            if ((options.sort[0] == '-') && (options.sort[1] == '-'))
            {
                delete options.sort;
            }

            if (Array.isArray(_options.joins))
            {
                options.joins = _options.joins;

                // pre-filter the joins
                options.joins = options.joins.filter(function(joinKey)
                {
                    if (!myClass.joins || !myClass.joins[joinKey])
                    {
                        if (joinKey !== '_root' && joinKey !== '_self') {
                            Debug.warn(myClass.joins, ' ' + ' does not have ' + joinKey);
                        }
                        return false;
                    }
                    if (authorization)
                    {
                        var joinAuthorization = null;
                        if (authorization.parent)
                        {
                            joinAuthorization = authorization.parent.getAuthorization(myClass.joins[joinKey].collection);
                        }
                        if (!joinAuthorization)
                        {
                            return true;
                        }

                        return !joinAuthorization.isAccessDenied('view');
                    }

                    return true;
                });
            }


            myClass.storage.get(myClass, query, options, function(err, results)
            {
                if (Array.isArray(options.groups))
                {
                    return callback(err, results);
                }
                if (Array.isArray(results))
                {
                    if (options.raw)
                    {
                        return callback(err, results);
                    }
                    results = results.map(function(result){
                        if (!(result instanceof myClass))
                        {
                            result = new myClass(result);
                        }
                        var denyKeys = [];
                        if (authorization)
                        {
                            denyKeys = authorization.getDeniedKeys(Object.keys(result), "view", result);
                            result[Schema._authorization] = authorization
                        }

                        denyKeys.forEach(function(key){
                            result[Schema._hidekeys]
                                .add(key)
                        });

                        // need to sanitize joined values
                        if (authorization && options.joins && options.joins.length)
                        {
                            options.joins.forEach(function(join)
                            {
                                if (!myClass.joins || !myClass.joins[join])
                                {
                                    return;
                                }

                                // is "raw" the key we are going to use here?
                                // it is intended to allow aggregated data to
                                // be included in the join which will not be
                                // objectified
                                if (myClass.joins[join].raw)
                                {
                                    // raw data is never filtered
                                    return;
                                }

                                var joinAuthorization = null;
                                if (authorization.parent)
                                {
                                    var useCollection = myClass.joins[join].model || myClass.joins[join].collection;
                                    joinAuthorization = authorization.parent.getAuthorization(useCollection);
                                }

                                if (!joinAuthorization)
                                {
                                    // if it doesn't exist, it means the collection does
                                    // not require authorization
                                    return;
                                }

                                var joinValues;
                                if (result[join] && !Array.isArray(result[join]))
                                {
                                    joinValues = [result[join]];
                                }
                                else if (result[join])
                                {
                                    joinValues = result[join];
                                }
                                else
                                {
                                    return;
                                }

                                joinValues.forEach(function(value)
                                {
                                    var joinDenyViewKeys = joinAuthorization.getDeniedKeys(Object.keys(value), "view", value);
                                    joinDenyViewKeys.forEach(function(key){
                                        value[Schema._hidekeys].add(key);
                                    });
                                });

                                joinValues = joinValues.filter(function(joinValue)
                                {
                                    var json = joinValue.toJSON();
                                    return Object.keys(json).length > 0;
                                });

                                result[join] = joinValues;
                            });
                        }

                        return result;
                    });
                }

                callback(err, results);
            });
        }
    }

    if (typeof myClass.crud.getOne == 'undefined')
    {
        myClass.crud.getOne = function(_query, _options, authorization, callback)
        {
            if (arguments.length === 2)
            {
                callback = _options;
                _options = {};
                authorization = null;
            }
            else if (arguments.length === 3)
            {
                callback = authorization;
                authorization = null;
            }

            _options = Object.assign({}, _options, {limit: 1});

            myClass.crud.get(_query, _options, authorization, function(err, results)
            {
                var result = null;

                if (Array.isArray(results) && results.length > 0)
                {
                    result = results[0];
                }

                callback(err, result);
            });
        };
    }

    if (typeof myClass.crud.count == 'undefined')
    {
        myClass.crud.count = function(_query, _options, authorization, callback)
        {
            if (arguments.length === 2)
            {
                callback = _options;
                authorization = null;
                _options = {};
            }
            else if (arguments.length === 3)
            {
                callback = authorization;
                authorization = null;
            }


            if (authorization)
            {
                if (authorization.isAccessDenied("view"))
                {
                    return callback("You do not have permission to perform this action.", null);
                }
                query = authorization.applyQueryFilters("view", _query);
            }

            var query = _query || {};
            Debug.debug('check query', JSON.stringify(query, null, '\t'));
            let isSubSearch = false;

            for (let key in query)
            {
                if (key.indexOf('.') != -1)
                {
                    isSubSearch = true;
                }
            }
            if (isSubSearch == true)
            {
                Debug.log('DOING SUBSEARCH COUNT');

                _options.doCount = true;
                myClass.crud.get(query, _options, authorization, function(e, results)
                {
                    Debug.log('count callback', e, results);
                    callback(e, results);
                });
            }
            else
            {
                Debug.log('DOING REGULAR COUNT');
                myClass.storage.count(myClass, query, callback);
            }

        }
    }

    if (typeof myClass.crud.update == 'undefined')
    {
        myClass.crud.update = function(_query, setter, authorization, callback)
        {
            if (arguments.length === 3)
            {
                callback = authorization;
                authorization = null;
            }

            const transaction = new Transaction();

            transaction.update(myClass, _query, setter, authorization);

            transaction.run((err, result) =>
            {
                if (Array.isArray(result))
                {
                    result = result[0];
                }

                callback(err, result);
            });
        }
    }

    if (typeof myClass.crud.delete == 'undefined')
    {
        myClass.crud.delete = function(_query, authorization, callback)
        {
            if (arguments.length === 2)
            {
                callback = authorization;
                authorization = null;
            }

            const transaction = new Transaction();

            transaction.delete(myClass, _query, authorization);
            transaction.run((err, result) =>
            {
                if (Array.isArray(result))
                {
                    result = result[0];
                }

                callback(err, result);
            });
        }
    }

    if (typeof myClass.crud.deleteMany == 'undefined')
    {
        myClass.crud.deleteMany = function(_query, authorization, callback)
        {
            if (arguments.length === 2)
            {
                callback = authorization;
                authorization = null;
            }

            var query = _query;
            var denyViewKeys = [];
            if (authorization)
            {
                if (authorization.isAccessDenied("delete"))
                {
                    return callback("You do not have permission to delete these items.", null);
                }
                query = authorization.applyQueryFilters("delete", query);
            }

            myClass.crud.get(query, {}, function(err, originals)
            {
                if (err)
                {
                    return callback(err, null);
                }

                if (!originals)
                {
                    // MWARDLE
                    // TODO: map this to a standard error type
                    return callback("Could not find the items. They may not exist, or you may not have permission to delete it.", null);
                }

                // TODO: is this check necessary??
                if (authorization)
                {
                    for (let i = 0; i < originals.length; i++)
                    {
                        if (authorization.isAccessDenied("delete", originals[i]))
                        {
                            return callback("You do not have permission to delete one or more items.", null);
                        }

                        originals[i][Schema._authorization] = authorization;
                    }
                }

                function beforeDeleteIter(index)
                {
                    if (index >= originals.length)
                    {
                        return doDelete();
                    }

                    myClass.emit('beforeDelete', originals[index], function(err)
                    {
                        if (err)
                        {
                            return callback(err, original);
                        }

                        process.nextTick(beforeDeleteIter, index + 1);
                    });
                }

                function doDelete()
                {
                    myClass.storage.deleteMany(myClass, originals, query, function(err, results)
                    {
                        if (results == null)
                        {
                            results = originals;
                        }

                        if (Array.isArray(results))
                        {
                            results = results.map((result) => {
                                if (result != null && !(result instanceof myClass))
                                {
                                    result = new myClass(result);
                                }
                                result[Schema._authorization] = authorization;
                                if (myClass.timestamps !== false)
                                {
                                    result.deletedTime = new Date().getTime();
                                }
                                if (authorization)
                                {
                                    denyViewKeys = authorization.getDeniedKeys(Object.keys(result), "view");
                                }
                                denyViewKeys.forEach(function(key){
                                    result[Schema._hidekeys].add(key);
                                });

                                return result;
                            });
                        }

                        if (err)
                        {
                            return callback(err, results);
                        }

                        originals = results;
                        afterDeleteIter(0);
                    });
                }

                function afterDeleteIter(index)
                {
                    if (index >= originals.length)
                    {
                        if (myClass.saveTrash !== false && typeof myClass.storage.saveTrash === 'function')
                        {
                            process.nextTick(saveTrashIter, 0);
                        }

                        // callback early
                        return callback(null, originals);
                    }

                    myClass.emit('afterDelete', originals[index], function(err)
                    {
                        if (err)
                        {
                            Debug.warn('Error returned from after delete hook', errors);
                        }

                        process.nextTick(afterDeleteIter, index + 1);
                    });
                }

                function saveTrashIter(index)
                {
                    // WE HAVE ALREADY CALLED BACK BY THE TIME WE HAVE REACHED THIS FUNCTION
                    if (index < originals.length)
                    {
                        var expireAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30 * 6);

                        myClass.storage.saveTrash(myClass, originals[index], expireAt, function(err, expireResult)
                        {
                            // DONT FAIL HERE!
                            // TODO: consider returning a warning of some kind...
                            if (err)
                            {
                                Debug.warn("Error returned when saving deleted object in trash", err);
                            }

                            process.nextTick(saveTrashIter, index + 1);
                        });
                    }
                }

                beforeDeleteIter(0);
            });
        }
    }

    if (typeof myClass.crud.create == 'undefined')
    {
        myClass.crud.create = function(_setter, authorization, callback)
        {
            if (arguments.length === 2)
            {
                callback = authorization;
                authorization = null;
            }

            const transaction = new Transaction();

            transaction.create(myClass, _setter, authorization);
            transaction.run((err, result) =>
            {
                if (Array.isArray(result))
                {
                    result = result[0];
                }

                callback(err, result);
            });
        }
    }

    if (typeof myClass.crud.clone === "undefined" && myClass.cloneable)
    {
        myClass.crud.clone = function(original, setter, options, authorization, callback)
        {
            const app = require_robinbase("app");
            if (arguments.length === 4)
            {
                callback = authorization;
                authorization = null;
            }
            else if (arguments.length == 3)
            {
                callback = options;
                authorization = null;
                options = {};
            }

            const creates = {};
            const cloneMap = {};

            Debug.log('original: ', original);
            Debug.log('setter', setter);


            function prepareClone(original, setter, thisClass, callback)
            {
                const originalId = original[thisClass.schema.useId];
                const newInstance = new thisClass(original._getData());
                // original = ;


                newInstance[thisClass.schema.useId] = thisClass.schema.generateId();
                // cloneMap[thisClass.modelKey] = cloneMap[thisClass.modelKey] || {};
                // cloneMap[thisClass.modelKey][originalId] = newInstance;

                Object.keys(setter).forEach(function(key)
                {
                    newInstance[key] = setter[key];
                });

                thisClass.emit(["beforeClone"], newInstance, function(err)
                {
                    if (err)
                    {
                        callback(err);
                        return;
                    }

                    creates[thisClass.modelKey] = creates[thisClass.modelKey] || [];
                    creates[thisClass.modelKey].push(newInstance);

                    if (typeof thisClass.joins === "object" && thisClass.joins != null)
                    {
                        const joinKeys = Object.keys(thisClass.joins)

                        // Debug.log('JOIN KEYS: ', joinKeys);

                        // TODO: make parallel
                        function joinIter(idx)
                        {
                            if (idx >= joinKeys.length)
                            {
                                callback(null, newInstance);
                                return;
                            }

                            const joinKey = joinKeys[idx];

                            const joinDef = thisClass.joins[joinKey];


                            if (!joinDef || !joinDef.cloneSetter)
                            {
                                // TODO: warn
                                joinIter(idx + 1);
                                return;
                            }

                            const options = {};
                            const joinCloneSetter = joinDef.cloneSetter;

                            let query = {};
                            query[joinDef.foreignKey] = original[joinDef.localKey];

                            if (joinDef.cloneFilter)
                            {
                                query = {$and: [query, joinDef.cloneFilter]};
                            }

                            if (typeof joinDef.cloneSort === 'object' && joinDef.cloneSort != null)
                            {
                                options.sort = joinDef.cloneSort;
                            }
                            else
                            {
                                options.sort = {createdTime: 1};
                            }

                            if ((options.sort[0] == '-') && (options.sort[1] == '-'))
                            {
                                delete options.sort;
                            }


                            const joinedClass = app.models[joinDef.collection];

                            if (!joinedClass)
                            {
                                // Debug.warn('NO JOIN CLASS OR JOIN CLONE SETTER', joinKey, joinDef, joinCloneSetter);
                                joinIter(idx + 1);
                                return;
                            }

                            const joinedCollection = joinDef.collection;
                            const joinedAuthorization = authorization && authorization.parent ? authorization.parent.getAuthorization(joinedCollection) : null;
                            const joinedSetter = {};

                            Object.keys(joinCloneSetter).forEach(function(setKey)
                            {
                                let value = joinCloneSetter[setKey];
                                if (typeof value === "string" && value[0] === "$")
                                {
                                    value = newInstance[value.substr(1)];
                                }

                                joinedSetter[setKey] = value;
                            });

                            joinedClass.crud.get(query, options, joinedAuthorization, function(err, joinedRecords)
                            {
                                if (err)
                                {
                                    callback(err);
                                    return;
                                }


                                if (typeof setter[joinKey] === 'object')
                                {
                                    const joinedRecordsMap = joinedRecords.reduce((res, record) =>
                                    {
                                        res[record._id.toHexString()] = record;
                                        return res;
                                    }, {});

                                    Debug.log('JOINED RECORS MAP', joinedRecordsMap);

                                    const useRecords = [];

                                    Object.keys(setter[joinKey]).forEach((id) =>
                                    {
                                        if (typeof setter[joinKey][id] !== 'object' || setter[joinKey][id] == null || id.match(/\-DEL$/))
                                        {
                                            // don't use it
                                            return;
                                        }
                                        else if (typeof joinedRecordsMap[id] === 'undefined')
                                        {
                                            useRecords.push(new joinedClass(setter[joinKey][id]));
                                            // setterMap[id] = joinedSetter;
                                        }
                                        else
                                        {
                                            Object.assign(joinedRecordsMap[id], setter[joinKey][id]);
                                            useRecords.push(joinedRecordsMap[id]);
                                        }
                                    });

                                    joinedRecords = useRecords;

                                    Debug.log('JOINED RECRODS:', joinedRecords);
                                }


                                // TODO: make parallel
                                function addCreatesIter(addCreatesIndex)
                                {
                                    if (addCreatesIndex >= joinedRecords.length)
                                    {
                                        joinIter(idx + 1);
                                        return;
                                    }

                                    prepareClone(joinedRecords[addCreatesIndex], joinedSetter, joinedClass, function(err)
                                    {
                                        if (err)
                                        {
                                            callback(err);
                                            return;
                                        }

                                        addCreatesIter(addCreatesIndex + 1);
                                    });
                                }

                                addCreatesIter(0);
                            });
                        }

                        joinIter(0);
                    }
                    else
                    {
                        callback(null, newInstance);
                    }
                });


            }



            prepareClone(original, setter, myClass, function(error, newInstance)
            {
                if (error)
                {
                    callback(error);
                    return;
                }


                // return callback(new Error('couldnt do it'));

                const insertModelKeys = Object.keys(creates);
                const transaction = new Transaction();
                const onCompletes = [];

                function insertModelsIter(insertModelsIndex)
                {
                    if (insertModelsIndex >= insertModelKeys.length)
                    {
                        runTransaction();
                        return;
                    }

                    const modelKey = insertModelKeys[insertModelsIndex];
                    const createClass = app.models[modelKey];
                    const createAuthorization = authorization && authorization.parent ? authorization.parent.getAuthorization(modelKey) : null;
                    const thisInserts = creates[modelKey];

                    // Debug.log('MODEL KEY: ', modelKey);
                    // Debug.log('THIS INSERTS: ', thisInserts);

                    function insertIter(insertIndex)
                    {
                        if (insertIndex >= thisInserts.length)
                        {
                            insertModelsIter(insertModelsIndex + 1);
                            return;
                        }

                        const resultIndex = transaction.stages.length;
                        transaction.create(createClass, thisInserts[insertIndex], createAuthorization);
                        onCompletes.push((results) =>
                        {
                            createClass.emit(["afterClone"], results[resultIndex], function(err)
                            {
                                if (err)
                                {
                                    Debug.warn("after clone called back with error", err);
                                }
                            });
                        });

                        insertIter(insertIndex + 1);

                        // createClass.crud.create(thisInserts[insertIndex], createAuthorization, function(err, result)
                        // {
                        //     if (err)
                        //     {
                        //         callback(err);
                        //         return;
                        //     }
                        //
                        //     myClass.emit(["afterClone"], result, function(err)
                        //     {
                        //         if (err)
                        //         {
                        //             Debug.warn("after clone called back with error", err);
                        //         }
                        //
                        //         insertIter(insertIndex + 1);
                        //     });
                        // });
                    }

                    insertIter(0);
                }

                function runTransaction()
                {
                    transaction.run((err, results) =>
                    {
                        if (err)
                        {
                            return callback(err);
                        }

                        onCompletes.forEach((fn) => fn(results));

                        callback(null, newInstance);
                    });
                }

                insertModelsIter(0);
            });
        };
    }

    myClass.crud.withAuthorization = function(authorization)
    {
        return {
            get: function(_query, _options, callback) {
                if (arguments.length === 2)
                {
                    callback = _options;
                    _options = {};
                }
                return myClass.crud.get(_query, _options, authorization, callback);
            },
            getOne: function(_query, _options, callback) {
                if (arguments.length === 2)
                {
                    callback = _options;
                    _options = {};
                }
                return myClass.crud.getOne(_query, _options, authorization, callback);
            },
            count: function(_query, callback) {
                return myClass.crud.count(_query, authorization, callback);
            },
            update: function(_query, setter, callback) {
                return myClass.crud.update(_query, setter, authorization, callback);
            },
            "delete": function(_query, callback) {
                return myClass.crud.delete(_query, authorization, callback);
            },
            create: function(_setter, callback) {
                return myClass.crud.create(_setter, authorization, callback);
            }
        }
    }
}

Crud.createTransaction = function(...args)
{
    return new Transaction(...args);
}

module.exports = Crud;
