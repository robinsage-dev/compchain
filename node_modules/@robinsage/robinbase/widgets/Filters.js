(function()
{
    var WidgetRegistry = require('../helpers/processor/WidgetRegistry.js');
    var WidgetHelper = require('../helpers/processor/WidgetHelper.js');
    var Utils = require('../helpers/processor/Utils.js');
    var Debug = require('../helpers/Debug.js');
    var Schema = require('../helpers/Schema.js');
    var View = require('../helpers/View.js');
    var Config = require('../config.js');
    const qs = require('qs');
    const querystring = require('querystring');

    var Filters = function Filters(args, processData)
    {
        var self = WidgetHelper.init(this, 'Filters');

        self.name = args.name || 'List Values';
        self.template = args.template || 'templates.empty';
        self._id = args._id || Math.random().toString(36).slice(2);
        //self.dataSource = args.dataSource || processData['tableSource'] || [];
        self.tableModel = args.tableModel || processData['tableModel'] || [];
        self.useId = args.useId || processData['useId'] || '_id';

        self.models = {};// {'accounts':require('../Account.js').view()};
        for (var key in Config.adminModels)
        {
            self.models[key] = Config.adminModels[key].view;
        }

        WidgetHelper.addWidgetMethods(self);
    }

    WidgetRegistry.register(Filters, function(args, processData, parentScope)
    {
        var obj = new Filters(args, processData);
        //just return the value for this attribute...
      //  WidgetHelper.processSubTemplate(obj, processData, parentScope);
        Debug.log('Filters Filters model', obj.tableModel);
        var model = obj.models[obj.tableModel];

        function isAllowed(attr)
        {
            var _isAllowed = true;
            if ((typeof attr.omitContexts != 'undefined') &&
                (Array.isArray(attr.omitContexts)))
            {
                if (attr.omitContexts.indexOf('filter') != -1)
                {
                    _isAllowed = false;
                }
            }
            if (_isAllowed == false)
            {
                return false;
            }
          /*  if (attr.type == 'join')
            {
                _isAllowed = false;
            }
            Debug.debug('attr.type', attr.type);
            if (attr.type.search(/^text:?/) != -1)
            {
                _isAllowed = false;
            }*/
          if ((attr.type != 'time:datetime') &&
              (attr.type != 'boolean') &&
              (attr.type != 'integer') &&
              (attr.type != 'float'))
          {
              _isAllowed = false;
          }
          if ((attr.type == 'text') && (Array.isArray(attr.values)))
          {
              _isAllowed = true;
          }
            return _isAllowed;
        }
        var output = '';



        const authData = processData.authData || {};
        const viewAttributes = Object.assign({}, model.getListAttributes(authData));
        const queryKeys = new Set(Object.keys(processData.query || {}));

        for (var key in viewAttributes)
        {
            if (isAllowed(viewAttributes[key]) != true)
            {
                continue;
            }
            Debug.log(processData.query);
            let useValue = '';

            if (typeof processData.query[key] != 'undefined')
            {
                queryKeys.delete(key);
                for (let nKey in processData.query[key])
                {
                    switch (nKey)
                    {
                        case 'eq':
                        {
                            useValue = Schema.utils.stripHtml(processData.query[key][nKey]);
                            break;
                        }
                        case 'in':
                        {
                            useValue = processData.query[key][nKey];
                            break;
                        }
                        case 'gte':
                        {
                            useValue = processData.query[key][nKey];
                            if (processData.query[key]['lte'])
                            {
                                useValue += ' to '+processData.query[key]['lte'];
                            }
                            break;
                        }
                    }
                }
            }

            var isOn = '';
            if (useValue != '')
            {
                isOn = ' on ';
            }

            output += `<div id="filter_${key}" class="filterContainer ${isOn}" key="${key}">
                        <label>${viewAttributes[key].label}</label>${View.displayFilter(viewAttributes[key], useValue, key)}
                        </div>`;
        }

        let existingQuery = {};
        for (let key of queryKeys.values())
        {
            if (key !== 'search')
            {
                existingQuery[key] = processData.query[key];
            }
        }

        existingQuery = querystring.parse(qs.stringify(existingQuery, {encode: true}));
        Debug.log('existing query', existingQuery);
        for (let key in existingQuery)
        {
            output += `<input type='hidden' name='${key.replace(/\[\$([^\]]+)\]/g, '[$1]')}' value='${existingQuery[key]}'>`;
        }



        parentScope.callback(null, output);

    });

    //no need to export as we this is being pushed to the widget registry.


}).call(this);
