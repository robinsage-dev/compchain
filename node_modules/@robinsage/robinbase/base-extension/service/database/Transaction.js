const Schema = require_robinbase('Schema');

class Transaction
{
    constructor()
    {
        this.stages = [];
        this.storageTransactions = new Map();
        this.rolledBack = false;

        this.running = false;
        this.index = 0;

        this.results = [];
        this.onSuccess = [];
    }

    update(Model, _query, setter, authorization)
    {

        const stage = {
            Model,
            type: 'update',
            query: _query,
            setter,
            authorization,
        };

        this.stages.push(stage);
    }

    ['delete'](Model, _query, authorization)
    {
        const stage = {
            Model,
            type: 'delete',
            query: _query,
            authorization,
        };

        this.stages.push(stage);
    }

    create(Model, _setter, authorization)
    {
        const stage = {
            Model,
            type: 'create',
            setter: _setter,
            authorization,
        };

        this.stages.push(stage);
    }

    runStage(callback)
    {
        const index = this.index;

        // Debug.log('STAGE IS: ', this.stages[index]);

        if (this.index >= this.stages.length)
        {
            // done
            return callback(null, this.results);
        }

        const stage = this.stages[index];

        let {
            Model,
            type,
            query = {},
            setter,
            authorization
        } = stage;

        if (authorization)
        {
            if (authorization.isAccessDenied(type))
            {
                return callback(new Error(`You do not have permission to ${type} this item.`));
            }

            query = authorization.applyQueryFilters(type, query);
        }

        const loadOriginal = (done) =>
        {
            if (stage.type === 'create')
            {
                stage.original = null;
                return done(null);
            }

            Model.storage.get(Model, query, {limit: 1}, (err, result) =>
            {
                if (err)
                {
                    return done(err);
                }

                if (Array.isArray(result) && result.length == 1)
                {
                    stage.original = new Model(result[0]);
                    return done();
                }
                else if (result.length === 0)
                {
                    return done(new Error('Could not find the item'));
                }
                else
                {
                    return done(new Error('Query matched more than one item'));
                }
            });
        };

        const runAction = (original, done) =>
        {
            switch(type)
            {
                case 'create':
                    this.runCreate(Model, setter, authorization, done);
                    break;
                case 'update':
                    this.runUpdate(Model, query, original, setter, authorization, done);
                    break;
                case 'delete':
                    this.runDelete(Model, query, original, authorization, done);
                    break;
            }
        };

        // 1. Make sure that we have the original data so we can restore it later
        loadOriginal((err) =>
        {
            if (err)
            {
                return callback(err);
            }

            // 2. Perform the action
            runAction(stage.original, (err, result) =>
            {
                if (err)
                {
                    return callback(err);
                }

                this.results.push(result);
                stage.result = result;


                // 3. Go to the next stage
                this.index += 1;
                process.nextTick(() =>
                {
                    this.runStage((err) =>
                    {
                        // 4. Rollback if necessary
                        if (err)
                        {
                            Debug.log('Rolling back transaction...', index);

                            this.performRollback(index, (rollbackErr) =>
                            {
                                if (rollbackErr)
                                {
                                    Debug.error('Unable to rollback transaction', index, rollbackErr);
                                }
                                else
                                {
                                    Debug.log('Rollback was successful');
                                }

                                callback(err);
                            });
                        }
                        else
                        {
                            Debug.log('transaction layer', index, 'received callback with no error');
                            callback(null);
                        }
                    });
                });

            });
        });
    }

    performRollback(index, callback)
    {
        this.rolledBack = true;
        Debug.log('ROLLING BACK:', index);

        const stage = this.stages[index];
        const {original, result, Model} = stage;

        if (stage.type === 'create')
        {
            // delete it
            const query = {[Model.schema.useId]: result[Model.schema.useId]};
            Model.storage.delete(Model, result, {[Model.schema.useId]: result[Model.schema.useId]}, callback);
        }
        else if (stage.type === 'update')
        {
            // set it back to what it was
            Model.storage.update(Model, original, {[Model.schema.useId]: result[Model.schema.useId]}, original, callback);
        }
        else if (stage.type === 'delete')
        {
            // put it back
            Model.storage.create(Model, original, callback);
        }
        else
        {
            // can't get here
            callback(new Error('Invalid type'));
        }
    }

    run(callback)
    {
        const runStartIndex = this.index;
        if (this.running)
        {
            return callback(new Error('The transaction is already running'));
        }
        else if (this.rolledback)
        {
            return callback(new Error('A transaction that has been rolled back cannot be continued'));
        }
        this.running = true;

        Debug.log('running transaction with ', this.stages.length, ' stages');
        this.runStage((err) =>
        {
            this.running = false;
            const onSuccess = this.onSuccess.slice();
            this.onSuccess = [];
            callback(err, this.results);

            if (!err)
            {
                onSuccess.forEach((fn) => fn());
            }
        });
    }

    rollback(callback)
    {
        this.performRollback(this.index, callback);
    }

    runCreate(Model, _setter, authorization, callback)
    {
        var setter = {};
        var authorizedSetter = {};
        if (authorization)
        {
            authorizedSetter = authorization.getCreateDefaultValues();
            for (var key in authorizedSetter)
            {
                if (typeof _setter[key] === "undefined")
                {
                    _setter[key] = authorizedSetter[key];
                }
            }
        }

        _setter = new Model(_setter || {});
        var denyCreateKeys = [];
        var denyViewKeys = [];
        if (authorization)
        {
            if (authorization.isAccessDenied("create", _setter))
            {
                return callback("You do not have permission to create this item.", null);
            }
            denyCreateKeys = authorization.getDeniedKeys(Object.keys(_setter), "create", _setter);
        }

        Object.keys(_setter).forEach((key) =>
        {
            if (_setter.hasOwnProperty(key) && typeof key !== 'function' && denyCreateKeys.indexOf(key) === -1)
            {
                setter[key] = _setter[key];
            }
            else if (typeof authorizedSetter[key] !== 'undefined')
            {
                setter[key] = authorizedSetter[key];
            }
        });

        if (Object.keys(setter).length === 0)
        {
            return callback("You do not have permission to create this item.", null);
        }

        var object = new Model(setter);

        object[Schema._authorization] = authorization;

        if (Model.timestamps !== false)
        {
            var currTime = new Date().getTime();
            object.createdTime = currTime;
            object.modifiedTime = currTime;

            if (Model.schema.props.createdTime.meta.type == 'datetime')
            {
                object.createdTime = new Date();
            }
            if (Model.schema.props.modifiedTime.meta.type == 'datetime')
            {
                object.modifiedTime = new Date();
            }
        }

        Model.emit(['beforeCreate', 'beforeSave'], object, (err) =>
        {
            if (err)
            {
                return callback(err, null);
            }

            try
            {
                Model.schema.prepareInstance(object);
            }
            catch (e)
            {
                return callback(e, null);
            }

            // filter out keys that do not belong
            var insert = object._getData();

            Model.storage.create(Model, insert, (err, result) =>
            {

                if (err)
                {
                    return callback(err, null);
                }

                if (result == null)
                {
                    return callback(null, object);
                }

                if (!(result instanceof Model))
                {
                    result = new Model(result);
                }

                // this is so the afterCreate and afterSave hooks can figure out what values changed
                // in the create
                result.markValuesAsChanged(Object.keys(object.getChangedValues()));
                result[Schema._originaldata] = object[Schema._originaldata];


                result[Schema._authorization] = authorization;

                // make sure temporary values are reattached to
                var originalKeys = new Set(Object.keys(object));
                var newKeys = new Set(Object.keys(result));

                for (let key of originalKeys)
                {
                    if (!newKeys.has(key))
                    {
                        result[key] = object[key];
                    }
                }

                this.onSuccess.push(() =>
                {
                    Model.emit(['afterCreate', 'afterSave'], result, true, (errors) =>
                    {
                        // DONT FAIL HERE
                        if (Array.isArray(errors) && errors.length)
                        {
                            Debug.warn('Error returned from afterCreate hook ', err);
                        }

                        if(authorization)
                        {
                            denyViewKeys = authorization.getDeniedKeys(Object.keys(result), "view", result);
                        }

                        denyViewKeys.forEach(function(key)
                        {
                            result[Schema._hidekeys].add(key);
                        });

                    });
                });

                callback(null, result);

            });
        });
    }

    runUpdate(Model, _query, original, setter, authorization, callback)
    {
        // TODO: throw here as query is required for update.
        var query = _query;
        var denySetterKeys = [];
        var denyViewKeys = [];
        if (authorization)
        {
            if (authorization.isAccessDenied("update"))
            {
                return callback("You do not have permission to update this item.", null);
            }
            query = authorization.applyQueryFilters("update", query);
        }

        if (!original)
        {
            // MWARDLE
            // TODO: map this to a standard error type
            return callback("Could not find the item. It may not exist, or you may not have permission to update it.", null);
        }

        if (authorization)
        {
            if (authorization.isAccessDenied("update"))
            {
                return callback("You do not have permission to update this item.", null);
            }
            original[Schema._authorization] = authorization;
            denySetterKeys = authorization.getDeniedKeys(Object.keys(setter), "update", original);
            denyViewKeys = authorization.getDeniedKeys(Object.keys(setter), "view", original);
        }

        denySetterKeys.forEach((key) =>
        {
            delete setter[key];
        });

        const updated = new Model(original);

        for (var key in setter)
        {
            updated[key] = setter[key];
        }

        Model.emit(['beforeUpdate', 'beforeSave'], updated, (err) =>
        {
            if (err)
            {
                return callback(err, null);
            }

            try
            {
                Model.schema.prepareInstance(updated);
            }
            catch (e)
            {
                return callback(e, null);
            }

            setter = updated.getChangedValues();

            // Debug.log('SETTER: ', setter);
            // Debug.log('ORIGINAL: ', original.toJSON());

            if (Model.timestamps !== false)
            {
                setter.modifiedTime = new Date().getTime();
                if (Model.schema.props.modifiedTime.meta.type == 'datetime')
                {
                    setter.modifiedTime = new Date();
                }
            }

            // TODO change query to use original's id
            // so that we know we are limiting it to one
            Model.storage.update(Model, updated, query, setter, (err, result) =>
            {
                if (result != null && !(result instanceof Model))
                {
                    result = new Model(result);
                }

                if (err || result == null)
                {
                    return callback(err, null);
                }

                result[Schema._authorization] = authorization;
                result[Schema._originaldata] = original[Schema._originaldata];

                // this is so the afterUpdate and afterSave hooks can figure out what values changed
                // in the update
                result.markValuesAsChanged(Object.keys(setter));

                // make sure temporary values are reattached to
                var originalKeys = new Set(Object.keys(updated));
                var newKeys = new Set(Object.keys(result));

                for (let key of originalKeys)
                {
                    if (!newKeys.has(key))
                    {
                        result[key] = updated[key];
                    }
                }

                this.onSuccess.push(() =>
                {
                    Model.emit(["afterUpdate", "afterSave"], result, true, (errors) =>
                    {
                        if (Array.isArray(errors) && errors.length)
                        {
                            // DONT RETURN AN ERROR ON AN AFTER UPDATE
                            // SINCE THE CALLER MAY THINK THE UPDATE
                            // DID NOT HAPPEN
                            Debug.warn('after update called back with error', errors);
                        }

                        denyViewKeys.forEach((key) =>
                        {
                            result[Schema._hidekeys].add(key);
                        });

                    });
                });

                callback(null, result);

            });
        });
    }

    runDelete(Model, _query, original, authorization, callback)
    {

        var query = _query;
        var denyViewKeys = [];
        if (authorization)
        {
            if (authorization.isAccessDenied("delete"))
            {
                return callback("You do not have permission to delete this item.", null);
            }
            query = authorization.applyQueryFilters("delete", query);
        }

        if (!original)
        {
            // MWARDLE
            // TODO: map this to a standard error type
            return callback("Could not find the item. It may not exist, or you may not have permission to delete it.", null);
        }

        // TODO: is this check necessary??
        if (authorization)
        {
            if (authorization.isAccessDenied("delete", original))
            {
                return callback("You do not have permission to delete this item.", null);
            }

            original[Schema._authorization] = authorization;
        }

        Model.emit('beforeDelete', original, (err) =>
        {
            if (err)
            {
                return callback(err, original);
            }

            Model.storage.delete(Model, original, query, (err, result) =>
            {
                if (result == null)
                {
                    result = original;
                }

                if (result != null && !(result instanceof Model))
                {
                    result = new Model(result);
                }

                result[Schema._authorization] = authorization;

                if (err)
                {
                    return callback(err, result);
                }

                if (Model.timestamps !== false)
                {
                    result.deletedTime = new Date().getTime();
                }

                // make sure temporary values are reattached to
                var originalKeys = new Set(Object.keys(original));
                var newKeys = new Set(Object.keys(result));

                for (let key of originalKeys)
                {
                    if (!newKeys.has(key))
                    {
                        result[key] = original[key];
                    }
                }

                this.onSuccess.push(() =>
                {
                    Model.emit('afterDelete', result, true, (errors) =>
                    {
                        // DONT FAIL HERE!
                        if (Array.isArray(errors) && errors.length)
                        {
                            Debug.warn('Error returned from after delete hook', errors);
                        }

                        if (result)
                        {
                            if (authorization)
                            {
                                denyViewKeys = authorization.getDeniedKeys(Object.keys(result), "view");
                            }
                            denyViewKeys.forEach((key) =>
                            {
                                result[Schema._hidekeys].add(key);
                            });
                        }


                        if (Model.saveTrash !== false && typeof Model.storage.saveTrash === 'function')
                        {
                            var expireAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30 * 6);

                            Model.storage.saveTrash(Model, result, expireAt, (err, expireResult) =>
                            {
                                // DONT FAIL HERE!
                                // TODO: consider returning a warning of some kind...
                                if (err)
                                {
                                    Debug.warn("Error returned when saving deleted object in trash", err);
                                }
                            });
                        }
                    });
                });

                callback(null, result);
            });
        });
    }
}

module.exports = Transaction;
