const snabbdom = require('snabbdom');
const h = require('snabbdom/h').default;
const EventEmitter = require('events').EventEmitter;

const HIGHLIGHT_TIME = 600;
const MAX_DISPLAY_ROWS = 200;

const timestamp$ = Symbol('RB/Table/timestamp');

class Table extends EventEmitter
{
    constructor(formData, objData = {})
    {
        super();
        this.parentNode = null;  // table does not have a parent node
        this.childNodes = [];
        this.formData = formData;
        this.objData = objData;
        this.patch = snabbdom.init(RBForm._modules);
        this.running = false;
        this.rows = Object.keys(objData).map((key) => this.buildRowFields(objData[key], key));
        this.vnode = null;
        this.highlight = {};
        this.deleted = new Map();
    }

    addItem(key, data, timestamp = null)
    {
        if (this.deleted.has(key))
        {
            // do not reinsert deleted items
            return;
        }

        if (!this.objData[key])
        {
            this.objData[key] = data;
            this.buildRow(data, key);
            this.highlight[key] = Date.now() + HIGHLIGHT_TIME;
            this.updateView();
        }
        else if (timestamp == null || this.objData[key][timestamp$] == null || this.objData[key][timestamp$] < timestamp)
        {
            this.objData[key] = data;
            this.highlight[key] = Date.now() + HIGHLIGHT_TIME;
            this.updateView();
        }

        if (timestamp != null)
        {
            this.objData[key][timestamp$] = timestamp;
        }
    }

    updateItem(key, data, timestamp = null)
    {
        if (this.deleted.has(key))
        {
            // do not reinsert deleted items
            return;
        }

        if (!this.objData[key])
        {
            this.objData[key] = data;
            this.buildRow(data, key);
            this.highlight[key] = Date.now() + HIGHLIGHT_TIME;
            this.updateView();
        }
        else if (timestamp == null || this.objData[key][timestamp$] == null || this.objData[key][timestamp$] < timestamp)
        {
            this.objData[key] = data;
            this.highlight[key] = Date.now() + HIGHLIGHT_TIME;
            this.updateView();
        }

        if (timestamp != null)
        {
            this.objData[key][timestamp$] = timestamp;
        }
    }

    reinsertItem(key, data, timestamp = null)
    {
        if (this.objData[key])
        {
            this.rows = this.rows.filter((row) => row.key !== key);
            //this.updateView();
        }


            this.objData[key] = data;
            this.buildRow(data, key);
            this.highlight[key] = Date.now() + HIGHLIGHT_TIME;
            //this.updateView();

        if (timestamp == null || this.objData[key][timestamp$] == null || this.objData[key][timestamp$] < timestamp)
        {
            this.objData[key] = data;
            this.highlight[key] = Date.now() + HIGHLIGHT_TIME;

        }

        if (timestamp != null)
        {
            this.objData[key][timestamp$] = timestamp;
        }
        this.updateView();
    }

    deleteItem(key, timestamp = null)
    {
        if (this.objData[key])
        {
            delete this.objData[key];
            this.rows = this.rows.filter((row) => row.key !== key);

            console.log('deleted item', key);

            this.updateView();
        }

        this.deleted[key] = timestamp;
        this.highlight[key] = Date.now() + HIGHLIGHT_TIME;
    }

    append(node)
    {
        //console.log('appending: ', node);
        if ((this.objData.live) && (this.objData.live.insertAt === 'prepend'))
        {
            this.rows = [node].concat(this.rows);
        }
        else
        {
            this.rows.push(node);
        }

        //console.log('this.rows', this.rows);
        node.parentNode = this;
    }

    updateView()
    {
        // console.log('updating view');
        if (this.running)
        {
            if (this.queuedUpdate)
            {
                clearTimeout(this.queuedUpdate);
            }

            this.queuedUpdate = setTimeout(() => {
                this.queuedUpdate = null;
                const newVNode = this.render(this.objData);
                try
                {
                    this.patch(this.vNode, newVNode);
                }
                catch(e)
                {
                    console.error('Could not update view:', e);
                    console.error('Current tree is: ', newVNode);

                    this.running = false;
                }
                this.vNode = newVNode;

                // update every 100 ms
                this.queuedUpdate = setTimeout(() => this.updateView(), 100);
            }, 1);


        }
    }

    calculateValue(key, attr = null, objData = {})
    {
        if (key == null) {
            return null;
        }
        let useKey = key;

        let value = this.getValue(useKey, objData);
        if (attr && typeof attr.join == 'string')
        {
            if (attr.join === "_self")
            {
                value = objData;
            }
            else if (attr.join.search(/_root\./) != -1)
            {
                let newJKey = attr.join.replace(/_root\./, '');
                value = this.rootForm.objData[newJKey];
            }
            else if (attr.join == '_root')
            {
                value = this.rootForm.objData;
            }
            else
            {
                value = objData[attr.join];
            }

            // is this the right place for this?
            if (typeof attr.defaultValue === 'string' && Array.isArray(value) && value.length === 0)
            {
                value = attr.defaultValue;
            }
            else if ((attr.type != 'join') && (attr.type != 'text') && attr.value && attr.valueMap)
            {
                value = replaceStr(attr.value, attr.valueMap, value);
            }
        }

        return value;
    }

    getValue(key, obj = {})
    {
        let keyParts = key.split('.');
        // let obj = this.objData;

        if (keyParts[0] === "_root")
        {
            obj = this.rootForm.objData;
            keyParts = keyParts.slice(1);
        }

        while(keyParts.length > 0)
        {
            obj = obj[keyParts.shift()];
            if (typeof obj === 'undefined')
            {
                return undefined;
            }
            else if (obj == null)
            {
                return null;
            }
        }

        return obj;
    }

    buildRow(obj, itemKey)
    {
        const {formData} = this;
        const {_attributes} = formData;

        const row = new FormRow(itemKey);
        const fields = Object.keys(_attributes).map((key) =>
        {
            const attr = _attributes[key];
            const useKey = itemKey + '.' + key;
            const initialValue = this.calculateValue(itemKey + '.' + key, attr, obj);
            if (typeof RBForm._fieldTypes[attr.type] === "function")
            {
                return new RBForm._fieldTypes[attr.type](null, useKey, attr, initialValue, 100);
            }
            else
            {
                console.warn(`Unknown field type '${attr.type}' for key '${key}'. Defaulting to text.`);
                return new RBForm._fieldTypes['text'](null, useKey, attr, initialValue, 100);
            }
        });

        fields.forEach((field) => row.append(field));
        this.append(row);
    }

    render()
    {
        return h('table.tableList', {
            attrs: {
                cellspacing: "0",
                cellpadding: "0",
            },
        }, [
            this.renderHead(),
            this.renderBody(),
        ]);
    }

    renderHead()
    {
        // TODO: we don't need to do this every time
        const {_attributes} = this.formData;
        let labels = Object.keys(_attributes).map((key) =>
        {
            return h('th#th_'+key + '.thKey', [_attributes[key].label || '']);
        });


        return h('thead', [
            h('tr', labels),
        ]);
    }

    renderBody()
    {
        const now = Date.now();
        if (this.rows.length === 0)
        {
            const {_attributes} = this.formData;
            return h('tbody', [
                h('tr', [
                    h('td', {
                        attrs: {
                            colspan: String(Object.keys(_attributes).length),
                        }
                    }, ['Waiting for new data...']),
                ]),
            ]);
        }

        const rows = this.rows.slice(0, MAX_DISPLAY_ROWS).map((row) =>
        {
            const value = this.objData[row.key];
            return row.render(value, now);
        });

        if (this.rows.length > MAX_DISPLAY_ROWS)
        {
            const {_attributes} = this.formData;

            rows.push(h('tr', [
                h('td', {
                    attrs: {
                        colspan: String(Object.keys(_attributes).length),
                    }
                }, [`${this.rows.length - MAX_DISPLAY_ROWS} more rows not displayed...`]),
            ]))
        }

        return h('tbody', rows);
    }

    run(parentEl) {
        this.running = true;
        var rootNode = document.createElement('div');
        parentEl.appendChild(rootNode);
        this.vNode = rootNode;

        console.log('table is running');

        this.updateView();
    }

    registerEnabledChecker() { /* Deliberately empty */ }
}

class FormRow
{
    constructor(key)
    {
        this.key = key;
        this.fields = [];
    }

    append(field)
    {
        this.fields.push(field);
        field.parentNode = this;
    }

    render(value, now)
    {
        const fields = this.fields.map((field) => {
            const value = this.parentNode.calculateValue(field.key, field.attr, this.parentNode.objData);
            const rendered = typeof field.renderValue === 'function' ? field.renderValue(value) : String(value);
            return h('td#listitemcell_' + field.key, {
                key: 'listitemcell_' + field.key,
            }, [rendered]);
        });

        const shouldHighlight = Boolean(this.parentNode.highlight[this.key]) && this.parentNode.highlight[this.key] >= now;

        return h('tr#listitem_' + this.key, {
            key: 'listitem_' + this.key,
            'class': {
                listItem: true,
                justModified: shouldHighlight,
            }
        }, fields);
    }
}

RB.Table = Table;

global.RBTable = Table;
global.FormRow = FormRow;
